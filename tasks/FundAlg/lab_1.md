# Лабораторная работа №1

- [Лабораторная работа №1](#лабораторная-работа-1)
  - [Общие требования](#общие-требования)
  - [О сборке](#о-сборке)
  - [Задание 1. Реализация шаблонного контейнера (аналог std::array)](#задание-1-реализация-шаблонного-контейнера-аналог-stdarray)
    - [Реализовать абстрактный шаблонный класс Container, который будет объявлять следующие чистые виртуальные методы:](#реализовать-абстрактный-шаблонный-класс-container-который-будет-объявлять-следующие-чистые-виртуальные-методы)
    - [В рамках пространства имен my\_container cоздать шаблонный контейнер Array\<T, N\> с фиксированным размером, аналог std::array, сделав его наследником класса Container](#в-рамках-пространства-имен-my_container-cоздать-шаблонный-контейнер-arrayt-n-с-фиксированным-размером-аналог-stdarray-сделав-его-наследником-класса-container)
    - [Покрыть созданный класс юнит тестами](#покрыть-созданный-класс-юнит-тестами)
  - [Задание 2. Реализация шаблонного контейнера (аналог std::list)](#задание-2-реализация-шаблонного-контейнера-аналог-stdlist)
    - [Реализовать шаблонный класс List, наследника Container в пространстве имен `my_container`](#реализовать-шаблонный-класс-list-наследника-container-в-пространстве-имен-my_container)
    - [Покрыть созданный класс юнит тестами](#покрыть-созданный-класс-юнит-тестами-1)
  - [Задание 3. Реализация шаблонного контейнера (аналог std::deque)](#задание-3-реализация-шаблонного-контейнера-аналог-stddeque)
    - [Реализовать шаблонный класс Deque, наследника List в пространстве имен `my_container`](#реализовать-шаблонный-класс-deque-наследника-list-в-пространстве-имен-my_container)
    - [Покрыть созданный класс юнит тестами](#покрыть-созданный-класс-юнит-тестами-2)
  - [Задание 4. Реализация шаблонного контейнера (аналог std::stack)](#задание-4-реализация-шаблонного-контейнера-аналог-stdstack)
    - [Реализовать шаблонный класс Stack в пространстве имен `my_container`](#реализовать-шаблонный-класс-stack-в-пространстве-имен-my_container)
    - [Покрыть созданный класс юнит тестами](#покрыть-созданный-класс-юнит-тестами-3)
  - [Задание 5. Реализация шаблонного контейнера (аналог std::vector)](#задание-5-реализация-шаблонного-контейнера-аналог-stdvector)
    - [Реализовать шаблонный класс `Vector<T>`, унаследованный от Container пространстве имен `my_container`.](#реализовать-шаблонный-класс-vectort-унаследованный-от-container-пространстве-имен-my_container)
  - [**Рекомендации:** Подробное описание можно найти по ссылке.](#рекомендации-подробное-описание-можно-найти-по-ссылке)
    - [**Покрытие класса юнит-тестами**](#покрытие-класса-юнит-тестами)
  - [**Задание 6. Реализация собственного умного указателя (аналог `std::unique_ptr`)**](#задание-6-реализация-собственного-умного-указателя-аналог-stdunique_ptr)
    - [**Реализовать шаблонный класс `UniquePtr<T>` в пространстве имен `my_smart_ptr`.**](#реализовать-шаблонный-класс-uniqueptrt-в-пространстве-имен-my_smart_ptr)
  - [**Рекомендации:** Подробное описание можно найти по ссылке.](#рекомендации-подробное-описание-можно-найти-по-ссылке-1)
    - [**Покрытие класса юнит-тестами**](#покрытие-класса-юнит-тестами-1)

## Общие требования
- Все задания реализуются на языке программирования C++ (стандарт C++14 и выше). Реализованные в заданиях
приложения не должны завершаться аварийно

- Во всех заданиях запрещено использование глобальных переменных (включая errno).

- Во всех заданиях запрещено использование оператора безусловного перехода (goto).

- Во всех заданиях запрещено пользоваться функциями, позволяющими завершить выполнение приложения из
произвольной точки выполнения, вне контекста исполнения функции main.

- Во всех заданиях при реализации необходимо разделять контексты работы с данными (поиск, сортировка,
добавление/удаление, модификация и т. п.) и отправка данных в поток вывода / выгрузка данных из потока ввода.

- Во всех заданиях все параметры функций и вводимые (с консоли, файла, командной строки) пользователем
данные должны подвергаться валидации в соответствии с типом валидируемых данных, если не сказано
обратное; валидация должна зависеть от типа данных и логики применения этих данных для выполнения
целевой подзадачи. При передаче аргументов приложению в командную строку, их количество также должно
валидироваться.

- Во всех заданиях необходимо контролировать ситуации с невозможностью пере/выделения памяти; во всех
заданиях необходимо корректно освобождать всю выделенную динамическую память.

- Все ошибки, связанные с операциями открытия файла, должны быть обработаны; все открытые файлы должны
быть закрыты.

- Во всех заданиях запрещено использование глобальных переменных. Во всех заданиях при реализации функций
необходимо обеспечить возможность обработки ошибок различных типов на уровне вызывающего кода.

- Во всех заданиях сравнение (на предмет эквивалентности или отношения порядка) вещественных чисел на
уровне функции должно использовать значение эпсилон, которое является параметром этой функции.

- Во всех заданиях при реализации функций необходимо максимально ограничивать возможность модификации
(если она не подразумевается) передаваемых в функцию параметров (используйте ключевое слово const), а также
вызывающего объекта, в случае вызова его методов.

- Для реализованных компонентов должны быть переопределены (либо перекрыты / оставлены реализации по
умолчанию - при обосновании) следующие механизмы классов C++: конструктор копирования, деструктор,
оператор присваивания.

- Во всех заданиях необходимо уменьшать количество копирований нетривиально копируемых объектов.

- Во всех заданиях необходимо проектировать компоненты с учетом SOLID принципов. Компонент не должен
управлять ресурсом, если это не является его единственной задачей.

- Запрещается пользоваться элементами стандартной библиотеки языка C, если существует их аналог в
стандартной библиотеке языка C++.

- Оступы должны быть по в соответствии с файлом clang-format, он лежит в корне репозитория [.clang-format](../.clang-format)

- Все файлы проекта должны быть проверены с использованием `cppcheck`. Все ошибки, которые он выдает должны быть исправлены

## О сборке

1. Каждое задание лаборатоной работы должно быть создано в отдельной папке
2. Задание должно быть собрано с использованием CMake (версии 3.10 и выше).
3. Структура проекта должна содержать следующие директории:
    - src/ — исходный код контейнера
    - include/ — заголовочные файлы
    - tests/ — unit тесты
    - build/ — директория для сборки (должна быть добавлена в .gitignore)
4. Основной CMakeLists.txt должен:
    - Определять основной исполняемый файл лабораторной работы
    - Подключать Google Test
    - Создавать отдельную цель (add_executable) для тестов
    - Включать тесты с помощью enable_testing() и add_test()
    - Содержать возможность создания отчета покрытия тестов с использованием gcov и lcov.
    - Содержать возможность проверить все файлы с использованием cppcheck одной командой
5. Код должен компилироваться без предупреждений и ошибок при использовании флагов компилятора -Wall -Wextra -Wpedantic -Werror -fsanitize=address -fsanitize=leak.
6.  Все зависимости должны либо загружаться автоматически


## Задание 1. Реализация шаблонного контейнера (аналог std::array)

### Реализовать абстрактный шаблонный класс Container, который будет объявлять следующие чистые виртуальные методы:
> 1. Конструктор по умолчания
> 2. Конструктор коирования
> 5. operator=
> 2. Деструктор
> 24. operator== (лексикографическое сравнение)
> 25. operator!= (лексикографическое сравнение)
> 20. size
> 21. max_size
> 19. empty

Подробнее о принимаемых и возвращаемых значениях можно прочитать по [ссылке](https://en.cppreference.com/w/cpp/named_req/Container)

### В рамках пространства имен my_container cоздать шаблонный контейнер Array<T, N> с фиксированным размером, аналог std::array, сделав его наследником класса Container

Реализовать следующие методы: (не забываем про final)

> 1. Конструктор по умолчанию и принимающий список инициализации
> 2. Деструктор
> 3. Контрутор копирования
> 4. Конструктор перемещения
> 5. operator=
> 6. at
> 7. operator[]
> 8. front
> 9. back
> 10. data
> 11. begin
> 12. cbegin
> 13. end
> 14. cend
> 15. rbegin
> 16. crbegin
> 17. rend
> 18. crend
> 19. empty
> 20. size
> 21. max_size
> 22. fill
> 23. swap
> 24. operator== (лексикографическое сравнение)
> 25. operator!= (лексикографическое сравнение)
> 26. operator< (лексикографическое сравнение)
> 27. operator<= (лексикографическое сравнение)
> 28. operator> (лексикографическое сравнение)
> 29. operator>= (лексикографическое сравнение)
> 30. operator<=> (лексикографическое сравнение)

** Подбробнее о возвращаемых и принимаемых значениях, а также поведении можно посмотреть по  [ссылке](https://en.cppreference.com/w/cpp/container/array)


### Покрыть созданный класс юнит тестами

1. Использовать Google Test (gtest) для написания тестов.
2. Создать отдельный модульный тестовый проект.
3. Тесты должны покрывать:
    - Конструкторы (по умолчанию, копирования, перемещения, со списком инициализации)
    - Операторы (присваивания, индексации, сравнения, swap)
    - Методы доступа (at, operator[], front, back, data)
    - Итераторы (begin, cbegin, end, cend, rbegin, crbegin, rend, crend)
    - Размерность контейнера (size, max_size, empty)
    - Метод fill
3. Для тестирования исключений использовать EXPECT_THROW и ASSERT_THROW.
3. Для тестирования сравнений использовать EXPECT_EQ, EXPECT_NE, EXPECT_LT, EXPECT_LE, EXPECT_GT, EXPECT_GE.
3. Структура тестов должна обеспечивать читаемость и модульность (разделение по группам функционала контейнера).
3. Минимизировать дублирование кода в тестах, используя фикстуры (TEST_F)
8. Обеспечить покрытие кода не менее 85%. Сделать отчет используя утилиты gcov и lcov. [ссылка на статью](https://dr-kino.github.io/2019/12/22/test-coverage-using-gtest-gcov-and-lcov/)


## Задание 2. Реализация шаблонного контейнера (аналог std::list)

### Реализовать шаблонный класс List<T>, наследника Container в пространстве имен `my_container`

---

Реализовать следующие методы:

1. Конструкторы (по умолчанию, копирования, перемещения, список инициализации)
2. Деструктор
3. Операторы `operator=`
4. Методы доступа:
   - `front`
   - `back`
5. Итераторы:
   - `begin`, `cbegin`
   - `end`, `cend`
   - `rbegin`, `crbegin`
   - `rend`, `crend`
6. Емкость:
   - `empty`
   - `size`
7. Модификаторы:
   - `clear`
   - `insert`
   - `erase`
   - `push_back`, `pop_back`
   - `push_front`, `pop_front`
   - `resize`
   - `swap`
8. Операторы сравнения (`==`, `!=`, `<`, `<=`, `>`, `>=`, `<=>`)

**Рекомендации:** Использовать двусвязный список. Подробное описание можно найти по [ссылке](https://en.cppreference.com/w/cpp/container/list).

### Покрыть созданный класс юнит тестами

1. Использовать Google Test (gtest) для написания тестов.
2. Создать отдельный модульный тестовый проект.
3. Тесты должны покрывать:
    - Конструкторы (по умолчанию, копирования, перемещения, со списком инициализации)
    - Операторы (присваивания, индексации, сравнения, swap)
    - Методы доступа
    - Итераторы
    - Размерность контейнера
4. Для тестирования исключений использовать EXPECT_THROW и ASSERT_THROW.
5. Для тестирования сравнений использовать EXPECT_EQ, EXPECT_NE, EXPECT_LT, EXPECT_LE, EXPECT_GT, EXPECT_GE.
6. Структура тестов должна обеспечивать читаемость и модульность (разделение по группам функционала контейнера).
7. Минимизировать дублирование кода в тестах, используя фикстуры (TEST_F)
8. Обеспечить покрытие кода не менее 85%. Сделать отчет используя утилиты gcov и lcov. [ссылка на статью](https://dr-kino.github.io/2019/12/22/test-coverage-using-gtest-gcov-and-lcov/)

---

## Задание 3. Реализация шаблонного контейнера (аналог std::deque)

### Реализовать шаблонный класс Deque<T>, наследника List в пространстве имен `my_container`

Реализовать следующие методы:

1. Конструкторы (по умолчанию, копирования, перемещения, список инициализации)
2. Деструктор
3. Операторы `operator=`
4. Методы доступа:
   - `at`
   - `operator[]`
   - `front`
   - `back`
5. Итераторы:
   - `begin`, `cbegin`
   - `end`, `cend`
   - `rbegin`, `crbegin`
   - `rend`, `crend`
6. Емкость:
   - `empty`
   - `size`
   - `max_size`
7. Модификаторы:
   - `clear`
   - `insert`
   - `erase`
   - `push_back`, `pop_back`
   - `push_front`, `pop_front`
   - `resize`
   - `swap`
8. Операторы сравнения (`==`, `!=`, `<`, `<=`, `>`, `>=`, `<=>`)

**Рекомендации:** Подробное описание можно найти по [ссылке](https://en.cppreference.com/w/cpp/container/deque).


### Покрыть созданный класс юнит тестами
1. Использовать Google Test (gtest) для написания тестов.
2. Создать отдельный модульный тестовый проект.
3. Тесты должны покрывать:
    - Конструкторы (по умолчанию, копирования, перемещения, со списком инициализации)
    - Операторы (присваивания, сравнения, swap)
    - Методы доступа
    - Итераторы
    - Размерность контейнера
4. Для тестирования исключений использовать EXPECT_THROW и ASSERT_THROW.
5. Для тестирования сравнений использовать EXPECT_EQ, EXPECT_NE, EXPECT_LT, EXPECT_LE, EXPECT_GT, EXPECT_GE.
6. Структура тестов должна обеспечивать читаемость и модульность (разделение по группам функционала контейнера).
7. Минимизировать дублирование кода в тестах, используя фикстуры (TEST_F)
8. Обеспечить покрытие кода не менее 85%. Сделать отчет используя утилиты gcov и lcov. [ссылка на статью](https://dr-kino.github.io/2019/12/22/test-coverage-using-gtest-gcov-and-lcov/)

---

## Задание 4. Реализация шаблонного контейнера (аналог std::stack)

### Реализовать шаблонный класс Stack<T> в пространстве имен `my_container`

Реализовать следующие методы:

1. Конструкторы (по умолчанию, копирования, перемещения, список инициализации)
2. Деструктор
3. Оператор `operator=`
4. Методы доступа:
   - `top`
5. Емкость:
   - `empty`
   - `size`
6. Модификаторы:
   - `push`
   - `pop`
   - `swap`
7. Операторы сравнения (`==`, `!=`, `<`, `<=`, `>`, `>=`, `<=>`)

**Рекомендации:** Можно использовать `Deque<T>` в качестве внутреннего контейнера. Подробное описание можно найти по [ссылке](https://en.cppreference.com/w/cpp/container/deque).


### Покрыть созданный класс юнит тестами
1. Использовать Google Test (gtest) для написания тестов.
2. Создать отдельный модульный тестовый проект.
3. Тесты должны покрывать:
    - Конструкторы (по умолчанию, копирования, перемещения, со списком инициализации)
    - Операторы (присваивания, сравнения, swap)
    - Методы доступа
4. Для тестирования исключений использовать EXPECT_THROW и ASSERT_THROW.
5. Для тестирования сравнений использовать EXPECT_EQ, EXPECT_NE, EXPECT_LT, EXPECT_LE, EXPECT_GT, EXPECT_GE.
6. Структура тестов должна обеспечивать читаемость и модульность (разделение по группам функционала контейнера).
7. Минимизировать дублирование кода в тестах, используя фикстуры (TEST_F)
8. Обеспечить покрытие кода не менее 85%. Сделать отчет используя утилиты gcov и lcov. [ссылка на статью](https://dr-kino.github.io/2019/12/22/test-coverage-using-gtest-gcov-and-lcov/)


## Задание 5. Реализация шаблонного контейнера (аналог std::vector)

### Реализовать шаблонный класс `Vector<T>`, унаследованный от Container пространстве имен `my_container`.

Реализовать следующие методы:

1. **Конструкторы:**
   - По умолчанию
   - Копирования
   - Перемещения
   - Со списком инициализации

2. **Деструктор**

3. **Оператор `operator=`**

4. **Методы доступа:**
   - `operator[]`
   - `at`
   - `front`
   - `back`
   - `data`

5. **Емкость:**
   - `empty`
   - `size`
   - `capacity`
   - `reserve`
   - `shrink_to_fit`

6. **Модификаторы:**
   - `clear`
   - `push_back`
   - `pop_back`
   - `insert`
   - `erase`
   - `resize`
   - `swap`

7. **Операторы сравнения (`==`, `!=`, `<`, `<=`, `>`, `>=`, `<=>`)**


**Рекомендации:** Подробное описание можно найти по [ссылке](https://en.cppreference.com/w/cpp/container/vector).
---

### **Покрытие класса юнит-тестами**

1. **Использовать Google Test (gtest) для написания тестов.**
2. **Создать отдельный модульный тестовый проект.**
3. **Тесты должны покрывать:**
   - Конструкторы (по умолчанию, копирования, перемещения, со списком инициализации)
   - Операторы (присваивания, сравнения, swap)
   - Методы доступа
   - Методы управления памятью (`reserve`, `shrink_to_fit`)
   - Методы модификации контейнера

4. **Для тестирования исключений использовать `EXPECT_THROW` и `ASSERT_THROW`.**
5. **Для тестирования сравнений использовать `EXPECT_EQ`, `EXPECT_NE`, `EXPECT_LT`, `EXPECT_LE`, `EXPECT_GT`, `EXPECT_GE`.**
6. **Структура тестов должна обеспечивать читаемость и модульность (разделение по группам функционала контейнера).**
7. **Минимизировать дублирование кода в тестах, используя фикстуры (`TEST_F`).**
8. **Обеспечить покрытие кода не менее 85%. Сделать отчет используя утилиты `gcov` и `lcov`.**

[Ссылка на статью по покрытию кода тестами](https://dr-kino.github.io/2019/12/22/test-coverage-using-gtest-gcov-and-lcov/)

## **Задание 6. Реализация собственного умного указателя (аналог `std::unique_ptr`)**

### **Реализовать шаблонный класс `UniquePtr<T>` в пространстве имен `my_smart_ptr`.**

Реализовать следующие методы:

1. **Конструкторы:**
   - По умолчанию
   - От указателя (`explicit UniquePtr(T* ptr)`)
   - Перемещения (`UniquePtr(UniquePtr&& other) noexcept`)

2. **Деструктор** (должен освобождать управляемый ресурс)

3. **Оператор `operator=`**
   - Оператор перемещающего присваивания (`UniquePtr<T>& operator=(UniquePtr&& other) noexcept`)
   - Запретить копирование (`delete` для конструктора копирования и оператора `operator=`)

4. **Методы доступа:**
   - `T* get() const noexcept`
   - `T& operator*() const`
   - `T* operator->() const noexcept`
   - `explicit operator bool() const noexcept`

5. **Модификаторы:**
   - `void reset(T* ptr = nullptr) noexcept`
   - `T* release() noexcept`
   - `void swap(UniquePtr& other) noexcept`

6. **Специализация для массивов (`UniquePtr<T[]>`)**
   - Должна поддерживать `operator[]`
   - Корректно освобождать память при уничтожении


**Рекомендации:** Подробное описание можно найти по [ссылке](https://en.cppreference.com/w/cpp/memory/unique_ptr).
---

### **Покрытие класса юнит-тестами**

1. **Использовать Google Test (gtest) для написания тестов.**
2. **Создать отдельный модульный тестовый проект.**
3. **Тесты должны покрывать:**
   - Конструкторы (по умолчанию, от указателя, перемещения)
   - Оператор перемещающего присваивания
   - Методы доступа (`get`, `operator*`, `operator->`, `operator bool`)
   - Модификаторы (`reset`, `release`, `swap`)
   - Корректную работу со специальной версией `UniquePtr<T[]>` для массивов

4. **Для тестирования исключений использовать `EXPECT_THROW` и `ASSERT_THROW` (если применимо).**
5. **Для тестирования операций использовать `EXPECT_EQ`, `EXPECT_NE` и другие соответствующие проверки.**
6. **Структура тестов должна обеспечивать читаемость и модульность (разделение по группам функционала контейнера).**
7. **Минимизировать дублирование кода в тестах, используя фикстуры (`TEST_F`).**
8. **Обеспечить покрытие кода не менее 85%. Сделать отчет используя утилиты `gcov` и `lcov`.**

[Ссылка на статью по покрытию кода тестами](https://dr-kino.github.io/2019/12/22/test-coverage-using-gtest-gcov-and-lcov/)
